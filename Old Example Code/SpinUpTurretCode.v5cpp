{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor LeftF = motor(PORT13, ratio18_1, true);\n\nmotor LeftB = motor(PORT11, ratio18_1, true);\n\nmotor RightF = motor(PORT9, ratio18_1, false);\n\nmotor RightB = motor(PORT7, ratio18_1, false);\n\ninertial DriveGyro = inertial(PORT10);\n\ncontroller Controller1 = controller(primary);\nmotor LeftM = motor(PORT12, ratio18_1, true);\n\nmotor RightM = motor(PORT8, ratio18_1, false);\n\nmotor Flywheel = motor(PORT2, ratio6_1, false);\n\nmotor Intake = motor(PORT6, ratio18_1, true);\n\ndigital_out stringLaunchL = digital_out(Brain.ThreeWirePort.H);\ndigital_out stringLaunchR = digital_out(Brain.ThreeWirePort.G);\ninertial TurretGyro = inertial(PORT1);\n\nrotation ATrack = rotation(PORT4, true);\n\nrotation BTrack = rotation(PORT3, true);\n\ndigital_out Transmission = digital_out(Brain.ThreeWirePort.E);\ndigital_out Blooper = digital_out(Brain.ThreeWirePort.F);\ndistance Distance = distance(PORT14);\ndistance MatchloaderDetector = distance(PORT19);\nled Light6 = led(Brain.ThreeWirePort.D);\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project:                                               \n//    Author:\n//    Created:\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n#include \"vex.h\"\n#include \"math.h\"\n#define PI 3.14159265\nusing namespace vex;\n\n//Global Vars:\nbool DC = false;\nint AT = 0;\nbool PXT = false;\nbool XT = true;\nbool BT = false;\n\n//Gyro Task//\n\nint initialDir = 270;\nfloat Dir = initialDir;\nfloat x = 15;\nfloat y = 71.5; //forward when initial Dir 0 and bot is right of alliance goal and perpendicular to the wall\nfloat truex = 0;\nfloat truey = 0;\nfloat turx = 0;\nfloat tury = 0;\nfloat A = 0;\nfloat B = 0;\nfloat prevA = 0; //middle\nfloat prevB = 0; //forward\nfloat prevDir = initialDir;\nfloat tuneAcc = .1;\nfloat AccX;\nfloat AccY;\nfloat ADFC = 0; //A distance from center in inches\nfloat BDFC = 4;//B distance from center in inches\nfloat SWC = (3.25 * PI); //small wheel circumference\nfloat DTG = 0;\nfloat ADTG = 0;\nfloat DBA = 0;\nfloat Gx = 122.63; //shortest distance of goal from wall\n\n\n\nint MyGyroTask()\n{\nDriveGyro.calibrate();\nDriveGyro.setRotation(initialDir, degrees);                        //Set Gyro to initial\nDriveGyro.setHeading(initialDir, degrees);\nATrack.setPosition(0,degrees);\nBTrack.setPosition(0,degrees);\nwhile(1)\n{\n //Gyro math//\n Dir = DriveGyro.rotation(degrees);\n //Position math//\n A = ATrack.position(turns) * SWC;\n B = BTrack.position(turns) * SWC;\n x += cos(((Dir + prevDir)/2)*PI/180) * (A - prevA) + sin(((Dir + prevDir)/2)*PI/180) * (B - prevB);\n y += sin(((Dir + prevDir)/2)*PI/180) * -(A - prevA) + cos(((Dir + prevDir)/2)*PI/180) * (B - prevB);\n tury = y + (3.64 * cos(((Dir)*PI/180) - .2783));\n turx = x + (3.64 * sin(((Dir)*PI/180) - .2783));\n truey = y + (5.84 * cos(((Dir)*PI/180) - .1722));\n truex = x + (5.84 * sin(((Dir)*PI/180) - .1722));\n prevA = A;\n prevB = B;\n prevDir = Dir;\n //Direction math//\n\n  wait(10, msec);\n vex::task::sleep(10);                              //cuts cpu usage\n}\nreturn(0);\n}\nvex::task t(MyGyroTask);                                  //Start Gyro Task\n\n\n//Turret Task//\nint turretState = 0;\nint initialDirTur = 90;\nfloat driveHead;\nfloat DirTur = 0;\nbool turretActive = false;\nfloat targetTurDir = 0;\nfloat turError = 0;\nfloat prevturError = 0;\nfloat turVolts = 0;\nfloat turGain = 2;\nfloat turDGain = 2;\nfloat turretBounds = 90;\nfloat customTTD = 0;\nbool beyondLimit = false;\nfloat offset = -4;\n\nint TurretTask()\n{\nTurretGyro.calibrate();\nTurretGyro.setRotation(initialDirTur, degrees);                        //Set Gyro to initial\nTurretGyro.setHeading(initialDirTur, degrees);\nwhile(1)\n{\n  DTG = (atan((Gx - turx)/(Gx - tury))) * 180 / PI;\n  if(tury >= Gx) {\n    DTG += 180;\n  }else if(turx >= Gx){\n    DTG += 360;\n  }\n  DTG += offset;\n\n  ADTG = (atan((17.5 - turx)/(17.5 - tury))) * 180 / PI;\n  if(tury >= 17.5) {\n    ADTG += 180;\n  }else if(turx >= 17.5 && tury < 17.5){\n    ADTG += 360;\n  }\n  ADTG += offset;\n\n  DirTur = TurretGyro.heading(degrees);\n  driveHead = DriveGyro.heading(degrees);\n\n  if(turretState == 0){\n    targetTurDir = DTG;\n  }\n  if(turretState == 1){\n    targetTurDir = driveHead - 180;\n    if (targetTurDir < 0){\n      targetTurDir += 360;\n    }\n  }\n  if(turretState == 2){\n    targetTurDir = driveHead - 135;\n    if (targetTurDir < 0){\n      targetTurDir += 360;\n    }\n  }\n  if(turretState == 3){\n    targetTurDir = ADTG;\n  }\n\n  if(DirTur > targetTurDir + 180){\n    DirTur -= 360;\n  }\n\n  turError = targetTurDir - DirTur;\n\n  if(driveHead > targetTurDir + 180){\n    driveHead -= 360;\n  }\n\n\n\n  if(turretActive){\n    if((driveHead > targetTurDir + turretBounds || driveHead < targetTurDir - turretBounds)){\n      turVolts = turGain * turError;\n      turVolts += (turError - prevturError) * turDGain;\n      if(turVolts > 12){\n        turVolts = 12;\n      }\n      if (turVolts < -12) {\n        turVolts = -12;\n      }\n    }else{\n      turVolts = 0;\n    }\n    LeftM.spin(forward, -turVolts, volt);\n  }\n\n  prevturError = turError;\n\n wait(15, msec);\n vex::task::sleep(10);                              //cuts cpu usage\n}\nreturn(0);\n}\nvex::task z(TurretTask);   \n\n//Flywheel Task//\nfloat Fspeed = 60;\nfloat gain = .04;\nfloat tbh = 8;\nfloat inputVolt = 0;\nfloat berror = Fspeed - Flywheel.velocity(percent);\nfloat prevberror = 1;\nint FlywheelVelControllerTask(){\n  Flywheel.setPosition(0,turns);\n  while(1){\n    berror = Fspeed - Flywheel.velocity(percent);\n\n    inputVolt += gain * berror;\n\n    if(signbit(berror) != signbit(prevberror)){\n      inputVolt = (inputVolt + tbh + tbh + tbh) * .25;\n      tbh = inputVolt;\n      prevberror = berror;\n    }\n  \n    if(inputVolt > 12){\n      inputVolt = 12;\n    }\n    if(inputVolt < 0){\n      inputVolt = 0;\n    }\n    Flywheel.spin(forward, inputVolt, volt);\n    prevberror = berror;\n    vex::task::sleep(10);\n  }\n  return(0);\n}\nvex::task f(FlywheelVelControllerTask);\n\n//Print Task//\nfloat ReadVar1 = 0;\nfloat DIS = 0;//Distance to goal\nfloat rberror = round(berror);\nint PrintTask(){\n  while(1){\n    Brain.Screen.printAt(10, 60, \"Gyro %0.1f\", DriveGyro.rotation(degrees));   //Output to brain screen\n    Brain.Screen.printAt(10, 120, \"x %.1f\", x);\n    Brain.Screen.printAt(10, 180, \"y %.1f\", y);\n    Controller1.Screen.setCursor(3, 1);\n    Controller1.Screen.print(\"G %.0f\", DriveGyro.heading());\n    Controller1.Screen.print(\" P %d\", XT);\n    Controller1.Screen.print(\" M %d\", AT);\n    float rberror = round(berror);\n    Controller1.Screen.print(\" E %.0f\", (rberror));\n    // printf(\"aTrack %.2f\", ATrack.position(turns));\n    // printf(\"BTrack %.2f\", BTrack.position(turns));\n    // printf(\"a %.2f\", A);\n    // printf(\"B %.2f\\n\", B);\n    // printf(\"TurGyro %.2f\", DirTur);\n    // printf(\"Gyro %.2f\", Dir);\n    // printf(\" xTrack %.2f\", x);\n    // printf(\" yTrack %.2f\", y);\n    // printf(\" xTur %.2f\", turx);\n    // printf(\" yTur %.2f\\n\", tury);\n    // printf(\" xtrue %.2f\", truex);\n    // printf(\" ytrue %.2f\", truey);\n    // printf(\" error %.4f\\n\", ReadVar1);\n    // Controller1.Screen.setCursor(3, 1);\n    // Controller1.Screen.print(\"F %.2f\");\n    // printf(\" Fspd %.2f\", Fspeed);\n    // printf(\"berror %.2f\", berror);\n    // printf(\" brightness %.2f\", Color1.brightness());\n    // printf(\" hue %.2f\\n\", Color1.hue());\n    printf(\" Spd %.2f\", (Flywheel.velocity(percent)));\n    // printf(\" DTG %.2f\", DTG);\n    // printf(\" DBA %.2f\\n\", DBA);\n    // printf(\" IV %.2f\\n\", inputVolt);\n    // printf(\" DIS %.4f\\n\", DIS);\n    // printf(\" driveHead %.2f\", driveHead);\n    printf(\" turError %.2f\\n\", turError);\n    // printf(\" TarDir %.2f\", targetTurDir);\n    // printf(\" turVolts %.2f\\n\", turVolts);\n\n    // Controller1.Screen.clearScreen();\n    Brain.Screen.clearScreen();\n    vex::task::sleep(10);\n  }\n  return(0);\n}\nvex::task p(PrintTask);\n\n\nfloat Turngain = .5;\nfloat TurnDgain = 3;\n\nvoid Turn(float Ang){\n  float ATurnSpeed = 0;\n  bool TurnLoop = true;\n  int stillCounter = 0;\n  float prevAngle = Dir;\n  int msecPassed = 0;\n  float error = 0;\n  float prevError = 0;\n\n  while(TurnLoop){\n\n    error = Ang - Dir;\n    ATurnSpeed = error * Turngain;\n    ATurnSpeed += (error - prevError) * TurnDgain;\n\n    if(ATurnSpeed > 12){\n      ATurnSpeed = 12;\n    }\n    if(ATurnSpeed < -12){\n      ATurnSpeed = -12;\n    }\n\n\n    LeftF.spin(forward, ATurnSpeed, volt);\n    LeftB.spin(forward, ATurnSpeed, volt);\n    \n    RightF.spin(reverse, ATurnSpeed, volt);\n    RightB.spin(reverse, ATurnSpeed, volt); \n\n    if(fabs(Dir - prevAngle) < .05 && msecPassed > 100){\n      stillCounter ++;\n    } else {\n      stillCounter = 0;\n    }\n    if(stillCounter > 10){\n      TurnLoop = false;\n    }\n    prevAngle = Dir;\n    prevError = error;\n\n    msecPassed += 10;\n    wait(10, msec);\n  }\n}\n\n// // /////\n// ////Turn Correction DrivePID///\n// float ktf = 0.02;//turn correction feed forward constant\n// float ktp = .065;//turn correction proportional constant\n// float turnBand = .05;\n// float kti = 0;\n// float kp = 2.5;//proportional constant\n// float kd = 0;\n\n// float exitLoop = .1; //how close it gets before it exits\n\n// void Drive(float Dis, float Speed = .95, float timeOut = 15000){\n//   float PIDinputVolt = 0;\n//   float targetPosB = (BTrack.position(turns) * 3.25 * PI) + Dis;\n//   float targetDir = DriveGyro.rotation(degrees);\n//   float Gerror = 0;\n//   float errorB = (targetPosB - (BTrack.position(turns) * 3.25 * PI));\n//   float prevErrorB = errorB;\n//   float compensate = ktf;\n//   float Lcomp = 1;\n//   float Rcomp = 1;\n//   float Itotal = 0;\n//   int msecPassed = 0;\n//   float prevPos = 0;\n//   int stillCounter = 0;\n//   bool PIDEnabled = true;\n  \n//   while(PIDEnabled){\n//     RightM.stop(hold);\n//     Gerror = targetDir - DriveGyro.rotation(degrees);\n\n//     errorB = targetPosB - ((BTrack.position(turns) * 3.25 * PI));\n\n//     compensate = ktf;\n//     compensate += ((Gerror) * ktp);\n//     compensate += Itotal;\n\n\n//     if(compensate < 0 && errorB > 0){\n//       Lcomp = 1 + compensate;\n//       Rcomp = 1;\n//     }\n//     if(compensate > 0 && errorB > 0){\n//       Rcomp = 1 - compensate;\n//       Lcomp = 1;\n//     }\n//     if(compensate < 0 && errorB < 0){\n//       Rcomp = 1 + compensate;\n//       Lcomp = 1;\n//     }\n//     if(compensate > 0 && errorB < 0){\n//       Lcomp = 1 - compensate;\n//       Rcomp = 1;\n//     }\n    \n//     PIDinputVolt = errorB * kp;\n//     PIDinputVolt += (prevErrorB - errorB) * kd;\n\n    \n//     if(PIDinputVolt > 12){\n//       PIDinputVolt = 12;\n//     }\n//     if(PIDinputVolt < -12){\n//       PIDinputVolt = -12;\n//     }\n\n//     LeftF.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n//     LeftB.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n//     RightF.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n//     RightB.spin(forward, PIDinputVolt * Speed * Rcomp, volt); \n\n//     if(fabs(BTrack.position(degrees) - prevPos) < 4 && msecPassed > 100){\n//       stillCounter ++;\n//     } else {\n//       stillCounter = 0;\n//     }\n//     if(stillCounter > 10){\n//       PIDEnabled = false;\n//     }\n\n//     if(fabs(Gerror) > turnBand){\n//       Itotal += (Gerror) * kti * errorB;\n//     }\n//     if(msecPassed > timeOut){\n//       PIDEnabled = false;\n//     }\n\n//     ReadVar1 = errorB;\n\n//     prevPos = BTrack.position(degrees);\n//     prevErrorB = errorB;\n\n//     msecPassed += 10;\n//     wait(10, msec);\n//   }\n//   LeftF.stop(brake);\n//   LeftB.stop(brake);\n//   RightF.stop(brake);\n//   RightB.stop(brake); \n//   RightM.stop(coast);\n// }\n\nfloat Tgain = .5;\nfloat TDgain = 3;\n\nvoid PTurn(float tx, float ty, bool fwd = true){\n  float ATurnSpeed = 0;\n  bool TurnLoop = true;\n  int stillCounter = 0;\n  float prevAngle = Dir;\n  int msecPassed = 0;\n  float error = 0;\n  float prevError = 0;\n  float tarAng = 0;\n  float DirDrive = DriveGyro.heading(degrees);\n\n  while(TurnLoop){\n    DirDrive = DriveGyro.heading(degrees);\n    if(!fwd){\n      DirDrive += 180;\n      if(DirDrive > 360){\n        DirDrive -= 360;\n      }\n    }\n    tarAng = (atan((tx - truex)/(ty - truey))) * 180 / PI;\n    if(truey >= ty) {\n      tarAng += 180;\n    }else if(truex >= tx && !(truey <= ty)){\n      tarAng += 360;\n    }\n\n    if(DirDrive > tarAng + 180){\n      DirDrive -= 360;\n    }\n\n    error = tarAng - DirDrive;\n    ATurnSpeed = error * Tgain;\n    ATurnSpeed += (error - prevError) * TDgain;\n\n    if(ATurnSpeed > 12){\n      ATurnSpeed = 12;\n    }\n    if(ATurnSpeed < -12){\n      ATurnSpeed = -12;\n    }\n\n\n    LeftF.spin(forward, ATurnSpeed, volt);\n    LeftB.spin(forward, ATurnSpeed, volt);\n    \n    RightF.spin(reverse, ATurnSpeed, volt);\n    RightB.spin(reverse, ATurnSpeed, volt); \n\n    if(fabs(Dir - prevAngle) < .05 && msecPassed > 100){\n      stillCounter ++;\n    } else {\n      stillCounter = 0;\n    }\n    if(stillCounter > 10){\n      TurnLoop = false;\n    }\n    prevAngle = Dir;\n    prevError = error;\n\n    msecPassed += 10;\n    wait(10, msec);\n  }\n}\n\n// /////\n////Turn Correction DrivePID///\nfloat ktf = 0;//turn correction feed forward constant\nfloat ktp = .03;//turn correction proportional constant\nfloat ktd = .01;\nfloat turnBand = .05;\nfloat kti = 0;\nfloat kp = 2.2;//proportional constant\nfloat kd = 3.5;\n\nfloat exitLoop = .1; //how close it gets before it exits\n\nvoid PDrive(float tx, float ty, float Speed = .95, float timeOut = 15000){\n  float PIDinputVolt = 0;\n  float targetDir = DriveGyro.rotation(degrees);\n  float Gerror = 0;\n  float prevGerror = Gerror;\n  float errorB = sqrt((truex - tx) * (truex - tx) + (truey - ty) * (truey - ty));\n  float prevErrorB = errorB;\n  float compensate = ktf;\n  float Lcomp = 1;\n  float Rcomp = 1;\n  float Itotal = 0;\n  int msecPassed = 0;\n  int stillCounter = 0;\n  bool PIDEnabled = true;\n  float DirDrive = DriveGyro.heading(degrees);\n  \n  while(PIDEnabled){\n    RightM.stop(hold);\n\n    DirDrive = DriveGyro.heading(degrees);\n\n    targetDir = (atan((tx - truex)/(ty - truey))) * 180 / PI;\n    if(truey >= ty) {\n      targetDir += 180;\n    }else if(truex >= tx && !(truey <= ty)){\n      targetDir += 360;\n    }\n\n    if(DirDrive > targetDir + 180){\n      DirDrive -= 360;\n    }\n\n    Gerror = targetDir - DirDrive;\n\n    errorB = sqrt((truex - tx) * (truex - tx) + (truey - ty) * (truey - ty));\n    errorB *= cos(Gerror * PI / 180);\n\n    if(Gerror > 90){\n      Gerror -= 180;\n    } else if(Gerror < -90){\n      Gerror += 180;\n    }\n\n\n    compensate = ktf;\n    compensate += (Gerror - prevGerror) * ktd;\n    compensate += ((Gerror) * ktp);\n    compensate += Itotal * kti;\n\n\n    if(compensate < 0 && errorB > 0){\n      Lcomp = 1 + compensate;\n      Rcomp = 1;\n    }\n    if(compensate > 0 && errorB > 0){\n      Rcomp = 1 - compensate;\n      Lcomp = 1;\n    }\n    if(compensate < 0 && errorB < 0){\n      Rcomp = 1 + compensate;\n      Lcomp = 1;\n    }\n    if(compensate > 0 && errorB < 0){\n      Lcomp = 1 - compensate;\n      Rcomp = 1;\n    }\n    \n    PIDinputVolt = errorB * kp;\n    PIDinputVolt += (errorB - prevErrorB) * kd;\n\n\n\n\n    \n    if(PIDinputVolt > 12){\n      PIDinputVolt = 12;\n    }\n    if(PIDinputVolt < -12){\n      PIDinputVolt = -12;\n    }\n\n    LeftF.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n    LeftB.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n    RightF.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n    RightB.spin(forward, PIDinputVolt * Speed * Rcomp, volt); \n\n    if(fabs(errorB - prevErrorB) < .01 && msecPassed > 100){\n      stillCounter ++;\n    } else {\n      stillCounter = 0;\n    }\n    if(stillCounter > 15){\n      PIDEnabled = false;\n    }\n\n    if(fabs(Gerror) > turnBand){\n      Itotal += (Gerror) * errorB;\n    }\n    if(msecPassed > timeOut){\n      PIDEnabled = false;\n    }\n\n    ReadVar1 = errorB;\n\n    prevErrorB = errorB;\n    prevGerror = Gerror;\n\n    msecPassed += 10;\n    wait(10, msec);\n  }\n  LeftF.stop(brake);\n  LeftB.stop(brake);\n  RightF.stop(brake);\n  RightB.stop(brake); \n  RightM.stop(coast);\n}\n\nvoid TDrive(float pwr, float msecs){\n  float counter = 0;\n  while (counter < msecs) {\n    LeftF.spin(forward, pwr, volt);\n    LeftB.spin(forward, pwr, volt);\n    RightF.spin(forward, pwr, volt);\n    RightB.spin(forward, pwr, volt);\n\n    counter += 10;\n    wait(10, msec);\n  }\n  LeftF.stop(brake);\n  LeftB.stop(brake);\n  RightF.stop(brake);\n  RightB.stop(brake); \n}\n\n\nvoid Shoot(int discs = 3, int msecs = 1000){\n  int discsShot = 0;\n\n  while(discs > discsShot){\n    if(discs > (discsShot + 1)){\n      Intake.spin(forward, 10, volt);\n    }else{\n      Intake.spin(forward, 12, volt);\n    }\n    int timeOut = 0;\n    while(berror < 25 && timeOut < 150){\n      wait(10, msec);\n      timeOut += 1;\n    }\n    Intake.stop(hold);\n    printf(\"fire\");\n    discsShot += 1;\n    wait(msecs, msec);\n  }\n  while(Distance.objectDistance(mm) < 30){\n    Intake.spin(forward, 12, volt);\n    if(Intake.velocity(percent) < 5){\n      break;\n    }\n  } \n  Intake.stop();\n}\n\nvoid ShootA(float initial = 8, float timeout = 2000, float accel = .05){\n  int counter = 0;\n  float IndexSpeed = initial;\n\n  while(counter < timeout && Distance.objectDistance(mm) < 30){\n    IndexSpeed += accel;\n    Intake.spin(forward, IndexSpeed, volt);\n    counter += 10;\n    wait(10, msec);\n  }\n\n  while(Distance.objectDistance(mm) < 30 && Intake.velocity(percent) > 5){\n    Intake.spin(forward, 12, volt);\n  } \n  Intake.stop();\n}\n\nvoid NotOnTrack(float Btime){\n  if(Btime < Brain.Timer.time(seconds)){\n    PTurn(118, 23);\n    PDrive(118, 23);\n    Turn(480);\n    stringLaunchL.set(true);\n    stringLaunchR.set(true);\n    wait(60,seconds);\n  }\n}\n\n\n\nvoid Scoot(){\n  while(MatchloaderDetector.objectDistance(mm) > 150){\n    RightM.spin(forward, 8, volt);\n  }\n  RightM.stop(brake);\n}\n\n//////////////////////////////////////////////////////////////////////////\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  wait(2, seconds);\n}\n//////////////////////////////////////////////////////////////////////////\n\nvoid autonomous(void) {\n  //DrivePID(float Dis, float Speed = .95, float ramp = 2, float timeOut = 15000)\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code\");\n  turretActive = true;\n\n  turretState = 3;\n  Fspeed = 72;\n  Intake.spin(reverse, 12, volt);\n  Light6.on();\n  wait(2, seconds);\n  Light6.off();\n  ShootA();\n  Intake.spin(reverse, 12, volt);\n  Light6.on();\n  wait(3, seconds);\n  Light6.off();\n  ShootA();\n  Intake.spin(reverse, 12, volt);\n  Light6.on();\n  wait(3, seconds);\n  Light6.off();\n  ShootA();\n\n  turretState = 0;\n\n  TDrive(-10, 400);\n  PTurn(17, 102);\n  PDrive(17, 102);\n  Turn(270);\n  Intake.spin(reverse, 12, volt);\n  TDrive(6, 1100);\n  TDrive(-10, 300);\n  PTurn(23, 118);\n  PDrive(23, 118);\n  Turn(360);\n  Intake.spin(reverse, 12, volt);\n  TDrive(8, 1400);\n  TDrive(-10, 300);\n\n  Fspeed = 77;\n\n  PTurn(58, 109);\n  Intake.spin(reverse, 12, volt);\n  PDrive(58, 109);\n  PTurn(69, 96);\n  PDrive(69, 96);\n  Turn(570);\n  wait(1,seconds);\n  ShootA();\n  PTurn(95, 63);\n  Fspeed = 72;\n  Intake.spin(reverse, 12, volt);\n  PDrive(95, 63);\n  PTurn(134, 63);\n  PDrive(134, 63);\n  Scoot();\n  Shoot(1, 1);\n\n  Intake.spin(reverse, 12, volt);\n  Light6.on();\n  wait(3, seconds);\n  Light6.off();\n  ShootA();\n  Intake.spin(reverse, 12, volt);\n  Light6.on();\n  wait(3, seconds);\n  Light6.off();\n  ShootA();\n\n  TDrive(-10, 400);\n  \n  PTurn(118, 23);\n  PDrive(118, 23);\n  Turn(485);\n  stringLaunchL.set(true);\n  stringLaunchR.set(true);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  printf(\"\\nexit\\n\");  \n}\n//////////////////////////////////////////////////////////////////////////\n\n\n//auto power toggle power, Increase power, Decrease Power, Off///\nbool manual = false;\nbool disableDrive = false;\n\n\nvoid superBrake(){\n  disableDrive = true;\n    LeftF.stop(hold);\n    LeftB.stop(hold);\n    LeftM.stop(hold);\n    RightF.stop(hold);\n    RightB.stop(hold);\n    RightM.stop(hold);\n}\n\n\nvoid enableDrive(){\n  disableDrive = false;\n  LeftF.setStopping(coast);\n  LeftB.setStopping(coast);\n  RightF.setStopping(coast);\n  RightB.setStopping(coast);\n  RightM.setStopping(coast);\n}\n\nvoid leftStrafe(){\n  RightM.spin(reverse, 12, volt);\n}\n\nvoid rightStrafe(){\n  RightM.spin(forward, 12, volt);\n}\n\nvoid stopStrafe(){\n  RightM.stop(coast);\n}\n\nbool YT = false;\nbool PYT = false;\n\n//bool BT = false;\nbool PBT = false;\n\nbool L2T = false;\nbool PL2T = false;\n\nint pos_f;\nint last_pos_f;\n\nint pos_d;\nint last_pos_d;\n\nint pos_g;\nint last_pos_g;\n\nint pos_t;\nint last_pos_t;\n\n//int AT = 0; moved to the top\nint PAT = 0;\n\nbool turretTime = true;\n//////////////////////////////////intake///\n\nvoid intakeR(){\n  Intake.setVelocity(100, percent);\n  Intake.spin(reverse);\n}\nvoid intake(){\n  Intake.setVelocity(100, percent);\n  Intake.spin(forward);\n}\nvoid intakeS(){\n  Intake.stop();\n}\n\n\n//////////////////////////////////////////////////////////////////////////\nvoid userControl(void) {\n  Brain.Screen.clearScreen();\n  // place driver control in this while loop\n    turretActive = false;\n    Intake.stop();\n    LeftF.setStopping(coast);\n    LeftB.setStopping(coast);\n    LeftM.setStopping(coast);\n    RightF.setStopping(coast);\n    RightB.setStopping(coast);\n    RightM.setStopping(coast);\n  while (true) {\n    DC = true;\n\n    if(!disableDrive){\n        LeftF.setVelocity(Controller1.Axis3.position(), percent);\n        LeftB.setVelocity(Controller1.Axis3.position(), percent);\n        \n        RightF.setVelocity(Controller1.Axis2.position(), percent);\n        RightB.setVelocity(Controller1.Axis2.position(), percent);   \n\n        LeftF.spin(forward);\n        LeftB.spin(forward);\n        RightF.spin(forward);\n        RightB.spin(forward);\n      if(turretTime){\n        Controller1.ButtonR2.pressed(rightStrafe);\n        Controller1.ButtonL2.pressed(leftStrafe);\n        Controller1.ButtonR2.released(stopStrafe);\n        Controller1.ButtonL2.released(stopStrafe);\n      } else {\n        LeftM.setVelocity(Controller1.Axis3.position(), percent);   \n        RightM.setVelocity(Controller1.Axis2.position(), percent); \n        RightM.spin(forward);\n        LeftM.spin(forward); \n      }   \n    }\n\n  if(Controller1.ButtonL2.pressing() && Controller1.ButtonR2.pressing() && turretActive){\n    superBrake();\n  } else {\n    enableDrive();\n  }\n\n\n\n  \n\n  Controller1.ButtonL1.pressed(intakeR);\n  Controller1.ButtonR1.pressed(intake);\n  Controller1.ButtonR1.released(intakeS);\n  Controller1.ButtonL1.released(intakeS);\n\n\n    // if(!manual){\n    //   DIS = sqrt(((turx-Gx)*(turx-Gx))+((tury-Gx)*(tury-Gx)));\n    //   Fspeed = sqrt((DIS + 10.4632)/.0204929) + (-.02235 * DIS - 1.163);////REDO\n    //   if(Fspeed < 50){\n    //     Fspeed = 50;\n    //   }\n    //   if (Fspeed > 100){\n    //     Fspeed = 100;\n    //   }\n    // }\n\n\n\n    bool buttonA = Controller1.ButtonA.pressing();\n    if(buttonA && !PAT){\n      PAT = true;\n      AT += 1;\n      if (AT > 2) { \n        AT = 0;\n      }\n    } else if(!buttonA){\n      PAT = false;\n    }\n    if (AT == 0) {\n      DIS = sqrt(((turx-Gx)*(turx-Gx))+((tury-Gx)*(tury-Gx)));\n      if(DIS > 25){\n        Fspeed = 5.8 * sqrt(DIS - 25) + 41;\n      } else {\n        Fspeed = 25;\n      }\n      if(Fspeed < 50){\n        Fspeed = 50;\n      }\n      if (Fspeed > 100){\n        Fspeed = 100;\n      }\n    }\n    if (AT == 1) {\n      Fspeed = 100;\n      manual = false;\n    }\n    if (AT == 2) {\n      Fspeed = 0;\n      manual = false;\n    }\n\n    bool buttonB = Controller1.ButtonB.pressing();\n    if(buttonB && !PBT){\n      PBT = true;\n      BT = !BT;\n      tbh = 8;\n      inputVolt = 0;\n      berror = Fspeed - Flywheel.velocity(percent);\n      prevberror = 1;\n    } else if(!buttonB){\n      PBT = false;\n    }\n\n    if(Controller1.ButtonX.pressing()){\n      if(last_pos_t == 0){\n        if(pos_t == 0){\n          turretState = 1;\n          wait(1,seconds);\n          Transmission.set(true);\n          LeftM.stop(coast);\n          turretTime = false;\n          turretActive = false;\n          pos_t = 1;\n          last_pos_t = 1;\n        } else if (pos_t == 1) {\n          turretState = 0;\n          Transmission.set(false);\n          LeftM.stop(coast);\n          turretTime = true;\n          turretActive = true;\n          pos_t = 0;\n          last_pos_t = 1;\n        }\n      }\n    } else {\n      last_pos_t = 0;\n    }\n\n\n\n    if(Controller1.ButtonDown.pressing() && Controller1.ButtonLeft.pressing()){\n      if(last_pos_f == 0){\n        if(pos_f == 0){\n          pos_f = 1;\n          stringLaunchR.set(true);\n          last_pos_f = 1;\n        } else if (pos_f == 1) {\n          pos_f = 0;\n          stringLaunchR.set(false);\n          last_pos_f = 1;\n        }\n      }\n    } else {\n      last_pos_f = 0;\n    }\n\n    if(Controller1.ButtonDown.pressing() && Controller1.ButtonRight.pressing()){\n      if(last_pos_g == 0){\n        if(pos_g == 0){\n          pos_g = 1;\n          stringLaunchL.set(true);\n          last_pos_g = 1;\n        } else if (pos_g == 1) {\n          pos_g = 0;\n          stringLaunchL.set(false);\n          last_pos_g = 1;\n        }\n      }\n    } else {\n      last_pos_g = 0;\n    }\n\n    // if(Controller1.ButtonUp.pressing() && Controller1.ButtonRight.pressing()){\n    //   if(last_pos_d == 0){\n    //     if(pos_d == 0){\n    //       pos_d = 1;\n    //       stringLaunchR.set(true);\n    //       last_pos_d = 1;\n    //     } else if (pos_d == 1) {\n    //       pos_d = 0;\n    //       stringLaunchR.set(false);\n    //       last_pos_d = 1;\n    //     }\n    //   }\n    // } else {\n    //   last_pos_d = 0;\n    // }\n    if(Controller1.ButtonUp.pressing()){\n      if(last_pos_d == 0){\n        if(pos_d == 0){\n          pos_d = 1;\n          Blooper.set(true);\n          AT = 1;\n          last_pos_d = 1;\n        } else if (pos_d == 1) {\n          pos_d = 0;\n          Blooper.set(false);\n          AT = 0;\n          last_pos_d = 1;\n        }\n      }\n    } else {\n      last_pos_d = 0;\n    }\n\n\n\n    wait(20, msec);\n  }\n}\n//////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////\nint main() {\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n  // Prevent main from exiting with an infinite loop.\n  while (true) {\n    wait(100, msec);\n  }\n}","textLanguage":"cpp","rconfig":[{"port":[13],"name":"LeftF","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[11],"name":"LeftB","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"RightF","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[7],"name":"RightB","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"DriveGyro","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[12],"name":"LeftM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8],"name":"RightM","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"Flywheel","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[6],"name":"Intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[8],"name":"stringLaunchL","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[7],"name":"stringLaunchR","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[1],"name":"TurretGyro","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[4],"name":"ATrack","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"true"},"triportSourcePort":22},{"port":[3],"name":"BTrack","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"true"},"triportSourcePort":22},{"port":[5],"name":"Transmission","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[6],"name":"Blooper","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[14],"name":"Distance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[19],"name":"MatchloaderDetector","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{"id":"partner"},"triportSourcePort":22},{"port":[4],"name":"Light6","customName":true,"deviceType":"LED","deviceClass":"led","setting":{"id":"partner"},"triportSourcePort":22}],"slot":3,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}