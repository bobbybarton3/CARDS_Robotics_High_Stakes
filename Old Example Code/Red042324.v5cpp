{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\ncontroller Controller1 = controller(primary);\nmotor R1 = motor(PORT11, ratio6_1, false);\n\nmotor R2 = motor(PORT12, ratio6_1, false);\n\nmotor R3 = motor(PORT13, ratio6_1, false);\n\nmotor R4 = motor(PORT14, ratio6_1, true);\n\nmotor L1 = motor(PORT20, ratio6_1, true);\n\nmotor L2 = motor(PORT19, ratio6_1, true);\n\nmotor L3 = motor(PORT18, ratio6_1, true);\n\nmotor L4 = motor(PORT17, ratio6_1, false);\n\ndigital_out Wings = digital_out(Brain.ThreeWirePort.G);\ndigital_out PullUp = digital_out(Brain.ThreeWirePort.B);\ninertial Inertial1 = inertial(PORT8);\n\nrotation ATrack = rotation(PORT10, true);\n\nrotation BTrack = rotation(PORT9, false);\n\nmotor Intake1 = motor(PORT15, ratio6_1, false);\n\nmotor Intake2 = motor(PORT16, ratio6_1, true);\n\nmotor MatchLoader = motor(PORT2, ratio36_1, false);\n\n\n\n\n// Helper to make playing sounds from the V5 in VEXcode easier and\n// keeps the code cleaner by making it clear what is happening.\nvoid playVexcodeSound(const char *soundName) {\n  printf(\"VEXPlaySound:%s\\n\", soundName);\n  wait(5, msec);\n}\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n// ----------------------------------------------------------------------------\n//                                                                            \n//    Project:                                               \n//    Author:\n//    Created:\n//    Configuration:        \n//                                                                            \n// ----------------------------------------------------------------------------\n\n// Include the V5 Library\n#include \"vex.h\"\n#define PI 3.14159265\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// Begin project code\n\n//Odometry Task-------------------------------------------\n\n//BOT INITIAL POSITION AND DIRECTION VALUES\n\n//front left corner (the tip of the piece of channel with the wing joint) is 24 inches from the wall.\n//Back left corner of bot 12.5 in from wall\ndouble initialDir = -90; //0 when facing Red Goal\n//(x,y) == (0,0) at bottom right when facing Red goal\ndouble initialX = 37; //increases as you approach Red Goal\ndouble initialY = 6.75; //increases from right to left when facing red goal\n\ndouble Dir = initialDir; //Live Direction\ndouble x = initialX; //Live X\ndouble y = initialY; //Live Y\ndouble truex = 0; //Position of center of bot\ndouble truey = 0; //Position of center of bot\ndouble prevA = 0; //sideways\ndouble prevB = 0; //forward\ndouble prevDir = initialDir;\n\n//Robot Physical Constants\nfloat ADFC = 0; //A distance from center in inches\nfloat BDFC = 0;//B distance from center in inches\nfloat SSWC = (2 * PI); //small small wheel Circumference\n\nint MyGyroTask()\n{\nInertial1.calibrate();\nInertial1.setRotation(initialDir, degrees);                   //Set Gyro to initial\nInertial1.setHeading(initialDir, degrees);\nATrack.setPosition(0,degrees);\nBTrack.setPosition(0,degrees);\nwhile(1)\n{\n  //Gyro math//\n  Dir = Inertial1.rotation(degrees) * (360.0/357.0); //Because the gyro is off\n  float DirRad = Dir * PI / 180;\n  //Position math//\n  float A = ATrack.position(turns) * SSWC;\n  float B = BTrack.position(turns) * SSWC;\n\n  x += (-sin(((DirRad + prevDir)/2)) * (A - prevA) + cos(((DirRad + prevDir)/2)) * (B - prevB));\n  y += (-cos(((DirRad + prevDir)/2)) * (A - prevA) + -sin(((DirRad + prevDir)/2)) * (B - prevB));\n\n  truey = y + ((sin(Dir * PI / 180) * ADFC) + (-cos(Dir*PI/180) * BDFC));\n  truex = x + ((-cos(Dir * PI / 180) * ADFC) + (-sin(Dir*PI/180) * BDFC));\n  prevA = A;\n  prevB = B;\n  prevDir = DirRad;\n  //Direction math//\n\n  vex::task::sleep(10);                              //cuts cpu usage\n}\nreturn(0);\n}\nvex::task t(MyGyroTask);\n\n//Print Task--------------------------------------------------------\nfloat ReadVar1 = 0;\nint PrintTask(){\n  while(1){\n\n    // printf(\"RV1 %.2f\", ReadVar1);\n    printf(\"Gyro %.2f\", Dir);\n    // printf(\"A %.2f\", ATrack.position(turns));\n    // printf(\"B %.2f\", BTrack.position(turns));\n    // printf(\" xTrack %.2lf\", x);\n    // printf(\" yTrack %.2lf \", y);\n    printf(\" xtrue %.2f\", truex);\n    printf(\" ytrue %.2f\\n\", truey);\n\n    // Controller1.Screen.clearScreen();\n    Brain.Screen.clearScreen();\n    vex::task::sleep(200);\n  }\n  return(0);\n}\nvex::task p(PrintTask);\n\n//DRIVE FUNCTIONS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n//Turn Function-------------------------\n//turn to face a certain direction\n\n\n//Tuning Values\nfloat Turngain = .3;\nfloat TurnDgain = 1.3;\n//```````````````````\n\nvoid Turn(float Ang){\n  float ATurnSpeed = 0;\n  bool TurnLoop = true;\n  int stillCounter = 0;\n  float prevAngle = Dir;\n  int msecPassed = 0;\n  float error = 0;\n  float prevError = 0;\n\n  while(TurnLoop){\n\n    error = Ang - Dir;\n    ATurnSpeed = error * Turngain;\n    ATurnSpeed += (error - prevError) * TurnDgain;\n\n    if(ATurnSpeed > 12){\n      ATurnSpeed = 12;\n    }\n    if(ATurnSpeed < -12){\n      ATurnSpeed = -12;\n    }\n\n\n    L1.spin(forward, ATurnSpeed, volt);\n    L2.spin(forward, ATurnSpeed, volt);\n    L3.spin(forward, ATurnSpeed, volt);\n    L4.spin(forward, ATurnSpeed, volt);\n  \n    R1.spin(reverse, ATurnSpeed, volt);\n    R2.spin(reverse, ATurnSpeed, volt);\n    R3.spin(reverse, ATurnSpeed, volt);\n    R4.spin(reverse, ATurnSpeed, volt);\n\n    if(fabs(Dir - prevAngle) < .05 && msecPassed > 150){\n      stillCounter ++;\n    } else {\n      stillCounter = 0;\n    }\n    if(stillCounter > 10){\n      TurnLoop = false;\n    }\n    prevAngle = Dir;\n    prevError = error;\n\n    msecPassed += 10;\n    wait(10, msec);\n  }\n  L1.stop(brake);\n  L2.stop(brake);\n  L3.stop(brake);\n  L4.stop(brake); \n  R1.stop(brake);\n  R2.stop(brake);\n  R3.stop(brake);\n  R4.stop(brake);\n}\n\n//Point-Turn Function------------------------------\n//turns to face a specific point on the field\n\n//Similar Tuning ^\nfloat Tgain = .3;\nfloat TDgain = 1.3;\n//``````````````````````\n\nvoid PTurn(float tx, float ty, bool fwd = true){\n  float ATurnSpeed = 0;\n  bool TurnLoop = true;\n  int stillCounter = 0;\n  float prevAngle = Dir;\n  int msecPassed = 0;\n  float error;\n  float prevError;\n  float tarAng;\n  float DirDrive;\n\n  while(TurnLoop){\n    DirDrive = fmod(Dir, 360.0);\n    if(!fwd){\n      DirDrive += 180;\n      if(DirDrive > 360){\n        DirDrive -= 360;\n      }\n    }\n\n    tarAng = (atan((tx - truex)/(ty - truey))) * 180 / PI;\n    if(truey <= ty) {\n      tarAng += 270;\n    }else{\n      tarAng += 90;\n    }\n\n    error = tarAng - DirDrive;\n    if(error > 180){\n      error -= 360;\n    }\n    ATurnSpeed = error * Tgain;\n    ATurnSpeed += (error - prevError) * TDgain;\n\n    if(ATurnSpeed > 12){\n      ATurnSpeed = 12;\n    }\n    if(ATurnSpeed < -12){\n      ATurnSpeed = -12;\n    }\n\n    L1.spin(forward, ATurnSpeed, volt);\n    L2.spin(forward, ATurnSpeed, volt);\n    L3.spin(forward, ATurnSpeed, volt);\n    L4.spin(forward, ATurnSpeed, volt);\n  \n    R1.spin(reverse, ATurnSpeed, volt);\n    R2.spin(reverse, ATurnSpeed, volt);\n    R3.spin(reverse, ATurnSpeed, volt);\n    R4.spin(reverse, ATurnSpeed, volt);\n\n    if(fabs(Dir - prevAngle) < .05 && msecPassed > 150){\n      stillCounter ++;\n    } else {\n      stillCounter = 0;\n    }\n    if(stillCounter > 10){\n      TurnLoop = false;\n    }\n    prevAngle = Dir;\n    prevError = error;\n\n    msecPassed += 10;\n    wait(10, msec);\n  }\n  L1.stop(brake);\n  L2.stop(brake);\n  L3.stop(brake);\n  L4.stop(brake); \n  R1.stop(brake);\n  R2.stop(brake);\n  R3.stop(brake);\n  R4.stop(brake);\n}\n\n//Point-Drive function------------------------Tuned-ish, could be tuned more\n//Drives to a point\n\nfloat ktf = 0;//turn correction feed forward constant\nfloat ktp = .03;//turn correction proportional constant\nfloat ktd = 0;//.03; //suspicion that it only works well one way\nfloat turnBand = 0;\nfloat kti = 0;\nfloat kp = .6;//proportional constant\nfloat kd = .4;\n\n\nvoid PDrive(float tx, float ty, float Speed = .95, float timeOut = 15000, bool fwd = true){\n  float PIDinputVolt;\n  float Gerror; //direction error\n  float prevGerror;\n  float Derror; //distance error\n  float prevDerror;\n  float compensate = ktf;\n  float Lcomp = 1;\n  float Rcomp = 1;\n  float Itotal = 0;\n  int msecPassed = 0;\n  int stillCounter = 0;\n  bool PIDEnabled = true;\n  \n  while(PIDEnabled){\n\n    float DirDrive = fmod(Dir, 360.0);\n    if(!fwd){\n      DirDrive += 180;\n      if(DirDrive > 360){\n        DirDrive -= 360;\n      }\n    }\n\n    float tarAng = (atan((tx - truex)/(ty - truey))) * 180 / PI;\n    if(truey <= ty) {\n      tarAng += 270;\n    }else{\n      tarAng += 90;\n    }\n\n    Gerror = tarAng - DirDrive;\n    if(Gerror > 180){\n      Gerror -= 360;\n    }\n\n    Derror = sqrt((truex - tx) * (truex - tx) + (truey - ty) * (truey - ty));\n    Derror *= cos(Gerror * PI / 180);\n\n    if(Gerror > 90){\n      Gerror -= 180;\n    } else if(Gerror < -90){\n      Gerror += 180;\n    }\n\n\n    compensate = ktf;\n    compensate -= ((prevGerror - Gerror) * ktd);\n    compensate += ((Gerror) * ktp);\n    compensate += Itotal * kti;\n    if(Derror < 12 && Derror > -12){\n      compensate *= (fabs(Derror) / 12);\n    }\n\n    if(compensate < 0 && Derror > 0){\n      Lcomp = 1 + compensate;\n      Rcomp = 1;\n    }\n    if(compensate > 0 && Derror > 0){\n      Rcomp = 1 - compensate;\n      Lcomp = 1;\n    }\n    if(compensate < 0 && Derror < 0){\n      Rcomp = 1 + compensate;\n      Lcomp = 1;\n    }\n    if(compensate > 0 && Derror < 0){\n      Lcomp = 1 - compensate;\n      Rcomp = 1;\n    }\n\n    PIDinputVolt = Derror * kp;\n    PIDinputVolt += (Derror - prevDerror) * kd;\n\n    \n    if(PIDinputVolt > 12){\n      PIDinputVolt = 12;\n    }\n    if(PIDinputVolt < -12){\n      PIDinputVolt = -12;\n    }\n\n    L1.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n    L2.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n    L3.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n    L4.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n\n    R1.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n    R2.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n    R3.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n    R4.spin(forward, PIDinputVolt * Speed * Rcomp, volt);  \n\n    if(fabs(Derror - prevDerror) < .01 && msecPassed > 100){\n      stillCounter ++;\n    } else {\n      stillCounter = 0;\n    }\n    if(stillCounter > 13){\n      PIDEnabled = false;\n    }\n\n    ReadVar1 = Derror;\n\n    if(fabs(Gerror) > turnBand){\n      Itotal += (Gerror) * Derror;\n    }\n    if(msecPassed > timeOut){\n      PIDEnabled = false;\n    }\n\n\n    prevDerror = Derror;\n    prevGerror = Gerror;\n\n    msecPassed += 10;\n    wait(10, msec);\n  }\n  L1.stop(brake);\n  L2.stop(brake);\n  L3.stop(brake);\n  L4.stop(brake); \n  R1.stop(brake);\n  R2.stop(brake);\n  R3.stop(brake);\n  R4.stop(brake);\n}\n\n//Through-Drive function------------------------NOT tuned or checked Edits to be made\n//Drives through an array of points\n\nfloat Aktf = 0;//turn correction feed forward constant\nfloat Aktp = 0.01;//.02;//turn correction proportional constant\nfloat Aktps = 0;//.003;//propotional squared\nfloat Aktd = 0;//.1;\nfloat AktDis = 0;//.0085;\nfloat AturnBand = .05;\nfloat Akti = 0;\nfloat Akp = .6;//proportional constant\nfloat Akd = .7;\nfloat Glidekp = .055; //less is faster\n\nvoid ThrDrive(float XCoordArray[], float YCoordArray[], int arraySize = 1, float Speed = .95, float timeOut = 15000, bool fwd = true){\n  \n  \n\n  for(int i = 0; i < arraySize; i++ ){  \n    float PIDinputVolt;\n    float Gerror; //direction error\n    float prevGerror;\n    float Derror; //distance error\n    float prevDerror;\n    float compensate = ktf;\n    float beginx = truex;\n    float beginy = truey;\n    float Lcomp = 1;\n    float Rcomp = 1;\n    float Itotal = 0;\n    int msecPassed = 0;\n    int stillCounter = 0;\n    bool PIDEnabled = true;\n\n    //Calculate exit\n    //We need find a line that goes through the end point and is perpendicular to the line that goes through starting point and through the end point\n    float slope;\n    if(i != 0){\n      slope = (XCoordArray[i] - XCoordArray[i-1])/(YCoordArray[i] - YCoordArray[i-1]);//BUG WITH THIS LINE IF BOTH Y COORDS ARE SAME\n    } else {\n      slope = (XCoordArray[i] - beginx)/(YCoordArray[i] - beginy);\n    }\n\n\n    while(PIDEnabled){\n      int DirDrive = fmod(Dir, 360.0);\n      if(!fwd){\n        DirDrive += 180;\n        if(DirDrive > 360){\n          DirDrive -= 360;\n        }\n      }\n\n      int tarAng = (atan((XCoordArray[i] - truex)/(YCoordArray[i] - truey))) * 180 / PI;\n      if(truey <= YCoordArray[i]) {\n        tarAng += 270;\n      }else{\n        tarAng += 90;\n      }\n\n      Gerror = tarAng - DirDrive;\n      if(Gerror >= 180){\n        Gerror -= 360;\n      } else if(Gerror <= -180){ //JUST ADDED MAY NEED TO ADD TO OTHER\n        Gerror += 360;\n      }\n\n      Derror = sqrt((truex - XCoordArray[i]) * (truex - XCoordArray[i]) + (truey - YCoordArray[i]) * (truey - YCoordArray[i]));\n      if(Derror < 2){\n        Derror *= cos(Gerror * PI / 180);\n      }\n\n      compensate = Aktf;\n      compensate += (fabs(Gerror - prevGerror) * -Aktd);\n      compensate += (Gerror * Gerror * Aktps);\n      compensate += (fabs(Gerror) * Aktp);\n      compensate += (fabs(Itotal * Akti));\n      compensate += Derror * -AktDis;\n\n      if(compensate > 2){\n        compensate = 2;\n      }\n      if(PIDinputVolt < 0){\n        compensate = 0;\n      }\n\n      if(Gerror > 0){\n        Rcomp = 1 - compensate;\n        Lcomp = 1;\n      }\n      if(Gerror < 0){\n        Lcomp = 1 - compensate;\n        Rcomp = 1;\n      }\n      \n      if(i == arraySize - 1){\n        PIDinputVolt = Derror * Akp;\n        PIDinputVolt += (Derror - prevDerror) * Akd;\n      } else {\n        PIDinputVolt = 12;\n        PIDinputVolt -= (fabs(Gerror) * Glidekp);\n      }\n      \n      if(PIDinputVolt > 12){\n        PIDinputVolt = 12;\n      }\n      if(PIDinputVolt < -12){\n        PIDinputVolt = -12;\n      }\n\n\n\n      if(i == arraySize - 1){\n        if(fabs(Derror - prevDerror) < .01 && msecPassed > 100){\n          stillCounter ++;\n        } else {\n          stillCounter = 0;\n        }\n        if(stillCounter > 13){\n          PIDEnabled = false;\n        }\n      } else {\n        if(i == 0){\n          if(y + (slope * x) > (slope * XCoordArray[i]) + YCoordArray[i] && YCoordArray[i] > beginy) {\n            PIDEnabled = false;\n          } else if(y + (slope * x) < (slope * XCoordArray[i]) + YCoordArray[i] && YCoordArray[i] < beginy) {\n            PIDEnabled = false;\n          }\n        } else {\n          if(y + (slope * x) > (slope * XCoordArray[i]) + YCoordArray[i] && YCoordArray[i] > YCoordArray[i-1]) {\n            PIDEnabled = false;\n          } else if(y + (slope * x) < (slope * XCoordArray[i]) + YCoordArray[i] && YCoordArray[i] < YCoordArray[i-1]) {\n            PIDEnabled = false;\n          }\n        }\n\n      }\n\n      ReadVar1 = Gerror;\n\n      if(fabs(Gerror) > AturnBand){\n        Itotal += (Gerror) * Derror;\n      }\n      \n      if(msecPassed > timeOut){\n        PIDEnabled = false;\n      }\n\n\n      prevDerror = Derror;\n      prevGerror = Gerror;\n\n      L1.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n      L2.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n      L3.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n      L4.spin(forward, PIDinputVolt * Speed * Lcomp, volt);\n      R1.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n      R2.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n      R3.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n      R4.spin(forward, PIDinputVolt * Speed * Rcomp, volt);\n\n      msecPassed += 10;\n      wait(10, msec);\n    }\n\n  }\n  L1.stop(brake);\n  L2.stop(brake);\n  L3.stop(brake);\n  L4.stop(brake);\n  R1.stop(brake); \n  R2.stop(brake);\n  R3.stop(brake);\n  R4.stop(brake);\n}\n\nvoid PowerDrive(float timew, float vlt){\n      L1.spin(forward, vlt, volt);\n      L2.spin(forward, vlt, volt);\n      L3.spin(forward, vlt, volt);\n      L4.spin(forward, vlt, volt);\n      R1.spin(forward, vlt, volt);\n      R2.spin(forward, vlt, volt);\n      R3.spin(forward, vlt, volt);\n      R4.spin(forward, vlt, volt);\n      wait(timew, seconds);\n      L1.stop(brake);\n      L2.stop(brake);\n      L3.stop(brake);\n      L4.stop(brake); \n      R1.stop(brake);\n      R2.stop(brake);\n      R3.stop(brake);\n      R4.stop(brake);\n}\n\nbool WingsOut = false;\n\nbool PrevWingState = true;\n\nvoid ActivateWings(){\n  if(!WingsOut){\n    Wings.set(true);\n    WingsOut = true;\n  }\n}\n\nvoid DeactivateWings(){\n  if(WingsOut){\n    Wings.set(false);\n    WingsOut = false;\n  }\n}\n\nbool OdomDown = true;\n\nvoid PullUpOdom(){\n  if(OdomDown){\n    PullUp.set(true);\n    OdomDown = true;\n\n  }\n}\n\nvoid ActivateOdom(){\n  if(!OdomDown){\n    PullUp.set(false);\n    PullUp = false;\n  }\n}\n\nvoid AMLDown(){\n  MatchLoader.spin(reverse, 6, volt);\n  wait(500, msec);\n  MatchLoader.stop(coast);\n}\n\nvoid AMLUp(){\n  MatchLoader.spin(forward, 6, volt);\n  wait(500, msec);\n  MatchLoader.stop(coast);\n}\n\nvoid preAutonomous(void) {\n  // actions to do when the program starts\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"pre auton code\");\n  wait(1, seconds);\n}\n\nvoid autonomous(void) {\n  // MatchLoader.spinToPosition(-.5, turns);\n  // MatchLoader.setStopping(coast);\n\n\n  PDrive(37, 56);\n  PTurn(58, 60);\n  ActivateWings();\n  Intake1.spin(forward, 12, volt);\n  Intake2.spin(forward, 12, volt);\n  PDrive(58, 60);\n  Intake1.spin(forward, 2, volt);\n  Intake2.spin(forward, 2, volt);\n\n  DeactivateWings();\n  PTurn(20, 16, false);\n  PDrive(20, 16);\n  Turn(45);\n\n  AMLDown();\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n\n  AMLUp();\n\n  ActivateWings();\n\n  PDrive(60, 8);\n  PDrive(103, 12, .8);\n  PDrive(124, 24, .6);\n\n  DeactivateWings();\n\n  \n  Turn(-45);\n\n  AMLDown();\n\n  Turn(-80);\n  Turn(-40);\n\n  AMLUp();\n\n  ActivateWings();\n\n\n  PTurn(140, 42);\n  PDrive(135, 42);\n\n  PowerDrive(.25, -12);\n  wait(300, msec);\n  PowerDrive(.75, 12);\n\n  DeactivateWings();\n\n  PDrive(115, 10);\n  Turn(0);\n  PDrive(20, 16);\n\n  Turn(45);\n\n  AMLDown();\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n  Turn(10);\n  Turn(45);\n  wait(.5, seconds);\n\n  ActivateWings();\n\n  MatchLoader.setStopping(hold);\n  MatchLoader.spinToPosition(-.20, turns);\n\n  Intake1.spin(forward, 6, volt);\n  Intake2.spin(forward, 6, volt);\n\n  PDrive(71, 8);\n\n\n\n  \n\n\n  // MatchLoader.spinToPosition(-.05, turns);\n  // MatchLoader.setStopping(coast);\n\n  Brain.Screen.clearScreen();\n  Brain.Screen.print(\"autonomous code\");\n  // place automonous code here\n}\n\n  void IntakeIn(){\n    Intake2.spin(forward, 12, volt);\n    Intake1.spin(forward, 12, volt);\n  }\n\n  void IntakeOut(){\n    Intake2.spin(reverse, 12, volt);\n    Intake1.spin(reverse, 12, volt);\n  }\n\n  void IntakeStop(){\n    Intake2.stop(coast);\n    Intake1.stop(coast);\n  }\n\n  void IntakeHold(){\n    Intake2.stop(hold);\n    Intake1.stop(hold);\n  }\n\n\n\n\n\n  float MLStart = MatchLoader.position(turns);\n  bool PrevWingButton = false;\n\nvoid userControl(void) {\n  Brain.Screen.clearScreen();\n  // place driver control in this while loop\n    L1.setStopping(coast);\n    L2.setStopping(coast);\n    L3.setStopping(coast);\n    L4.setStopping(coast);\n    R1.setStopping(coast);\n    R2.setStopping(coast);\n    R3.setStopping(coast);\n    R4.setStopping(coast);\n\n  while (true) {\n    if(Controller1.ButtonL2.pressing() && MatchLoader.position(turns) > -.4){\n      MatchLoader.spin(reverse, 12, volt);\n    } else if(MatchLoader.position(turns) + .1 < MLStart && !Controller1.ButtonL2.pressing()){\n      MatchLoader.spin(forward, 12, volt);\n    } else {\n      MatchLoader.stop(coast);\n    }\n\n    \n    float Lstick = Controller1.Axis3.position(percent);\n    float Rstick = Controller1.Axis2.position(percent);\n\n\n\n    L1.setVelocity(Lstick, percent);\n    L2.setVelocity(Lstick, percent);\n    L3.setVelocity(Lstick, percent);\n    L4.setVelocity(Lstick, percent);\n    R1.setVelocity(Rstick, percent);\n    R2.setVelocity(Rstick, percent);\n    R3.setVelocity(Rstick, percent);\n    R4.setVelocity(Rstick, percent);\n\n    L1.spin(forward);\n    L2.spin(forward);\n    L3.spin(forward);\n    L4.spin(forward);\n    R1.spin(forward);\n    R2.spin(forward);\n    R3.spin(forward);\n    R4.spin(forward);\n\n    if(Controller1.ButtonL1.pressing() && Controller1.ButtonR1.pressing()){\n      IntakeHold();\n    }else if(Controller1.ButtonL1.pressing() && !Controller1.ButtonR1.pressing()){\n      IntakeIn();\n    } else if(!Controller1.ButtonL1.pressing() && Controller1.ButtonR1.pressing()){\n      IntakeOut();\n    } else if(!Controller1.ButtonL1.pressing() && !Controller1.ButtonR1.pressing()){\n      IntakeStop();\n    }\n  \n    if(Controller1.ButtonR2.pressing() && !PrevWingButton){\n      if(WingsOut){\n        DeactivateWings();\n      } else {\n        ActivateWings();\n      }\n    }\n    \n    PrevWingButton = Controller1.ButtonR2.pressing();\n\n    Controller1.ButtonA.pressed(ActivateOdom);\n    Controller1.ButtonB.pressed(PullUpOdom);    \n    \n\n\n    wait(20, msec);\n  }\n}\n\n\nint main() {\n  // create competition instance\n  competition Competition;\n\n  // Set up callbacks for autonomous and driver control periods.\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(userControl);\n\n  // Run the pre-autonomous function.\n  preAutonomous();\n\n\n\n\n  // Prevent main from exiting with an infinite loop.\n  while (true) {\n\n       \n\n    wait(20, msec);\n  }\n}","textLanguage":"cpp","rconfig":[{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[11],"name":"R1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[12],"name":"R2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[13],"name":"R3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[14],"name":"R4","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[20],"name":"L1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[19],"name":"L2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[18],"name":"L3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[17],"name":"L4","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[7],"name":"Wings","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[2],"name":"PullUp","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[8],"name":"Inertial1","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22},{"port":[10],"name":"ATrack","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"true"},"triportSourcePort":22},{"port":[9],"name":"BTrack","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false","id":"partner"},"triportSourcePort":22},{"port":[15],"name":"Intake1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[16],"name":"Intake2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[2],"name":"MatchLoader","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240219.10.00.00","appVersion":"3.1.0","minVersion":"3.1.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}